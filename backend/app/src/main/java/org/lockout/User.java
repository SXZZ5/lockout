package org.lockout;

import java.time.Instant;
import java.util.List;

/**
 * Full representation of a User
 * Embedded in every {@link UserRequest} and its child classes.
 */
public class User {
    /**
     * The email, not yet validated, as provided in the incoming request.
     */
    String email;

    /**
     * The password, as provided in the incoming request.
     * Only present for {@link User} instances created for login and signup requests otherwise
     * empty.
     */
    String password;

    /**
     * The session token, as provided in the incoming request.
     * Originates from {@link LambdaInput} instance for the current incoming request.
     */
    String sessiontoken;

    /**
     * Field holding reference of the full data for the current user.
     * Stays null until all authn/z are succesful.
     */
    Data dbuser;

    /**
     * Create the current user by wrapping {@link Dbops#makeUser}.
     * Should be preceded by a {@link #userAlreadyExists()} call somewhere earlier.
     * TODO: I should move the userAlreadyExists inside this function actually. Why take risk of leaving it on the caller.
     * @param sessiontoken The randomly generated sessionToken passed by the caller, forwarded to Dbops.
     * @return true if user was created correctly, false for any exceptions at all.
     */
    public boolean create(String sessiontoken) {
        try {
            Dbops.makeUser(this, sessiontoken);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Check for existence of a user for this.email.
     * @return true if already exists, false otherwise even for any exceptions.
     */
    public boolean userAlreadyExists() {
        try {
            Dbops.getUser(this);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Verify credentials provided in the incoming request.
     * ONLY FOR LOGIN WITH A PASSWORD.
     * @param sessiontoken Token generated by caller and forwarded to {@link Dbops#updateUserSession} for storing in db.
     * @return true if credentials are correct and login should succeed, false otherwise.
     */
    public boolean verifyCredentials(String sessiontoken) {
        try {
            this.dbuser = Dbops.getUser(this);
            Glogger.log(dbuser.toString());
            // returns true or false depending on whether password is correct or not.
            if (AppUtils.verifyPassword(this.password, dbuser.getPassword())) {
                Dbops.updateUserSession(this, sessiontoken);
                return true;
            } else {
                return false;
            }
        } catch (Exception e) {
            Glogger.log("User not found " + e.toString());
            return false;
        }
    }

    /**
     * Overwrite with gibberish, the contents of "secret" data based on cooldown.
     * Will not overwrite if the NOW_TIME is exactly between the supposed unlocking_time and (unlocking_time + 1) hour.
     * Used only by the {@link Getinfo} controller really.
     * Make sure not to do concealing for data update requests at all.
     */
    public void concealDbuser(){
        for(Info item: dbuser.getUserdata()){
            boolean toShow = false;
            toShow = AppUtils.hasTimeElapsedHours(item.getEpochTime(), item.getCooldownHours());
            toShow = toShow && !AppUtils.hasTimeElapsedHours(item.getEpochTime(), item.getCooldownHours() + 1);
            if (!toShow) {
                Instant minviewtime = Instant.ofEpochMilli(item.getEpochTime());
                minviewtime = minviewtime.plusSeconds(item.getCooldownHours()*60*60);
                Long tmp = minviewtime.toEpochMilli();
                item.setPwdhash(tmp.toString());
                item.setObfuscated("Don't do this cutie");
            }
        }
    }

    /**
     * Verify the correctness of Session Token provided in the incoming request.
     * Also, verify if the token is already expired or not.
     * @return true if token is correct and valid, false if incorrect or expired.
     */
    public boolean verifySession() {
        try {
            this.dbuser = Dbops.getUser(this);
            Glogger.log(dbuser.toString());
            if (AppUtils.verifyPassword(this.sessiontoken, dbuser.getSessiontoken())) {
                return !AppUtils.hasTimeElapsedMinutes(this.dbuser.getSessiontime(), 4);
            } else {
                return false;
            }
        } catch (Exception e) {
            Glogger.log("User not found " + e.toString());
            return false;
        }
    }

    /**
     * Add a new secret to the user.
     * Prepares/modifies
     * @param description the identifier for the secret (enforced uniqueness)
     * @param zkpwdhash raw password for now, will eventually change it to encrypted form. Depends on the client really.
     * @param obfuscated sequence that was used on client for entering password.
     * @throws Exception in cases like some other secret with the same identifier already exists.
     * TODO: for consistency this should not throw exeception, should return true or false like other methods like {@link #verifyCredentials}
     */
    public void createInfo(String description, String zkpwdhash, String obfuscated) throws Exception {
        for (Info item : dbuser.getUserdata()) {
            if (item.getDescription().equals(description)) {
                throw new RuntimeException("Provided descriptor already exists");
            }
        }

        Info newinfo = new Info();
        newinfo.setDescription(description);
        newinfo.setPwdhash(zkpwdhash);
        newinfo.setEpochTime(Instant.now().toEpochMilli());
        newinfo.setCooldownHours(7);
        newinfo.setObfuscated(obfuscated);

        dbuser.getUserdata().add(newinfo);
        Dbops.updateUserInfo(this);
    }

    /**
     * Delete a secret from the userdata.
     * @param description identifier for which secret to delete.
     * @throws Exception for example there is no secret with the given identifier or just some connection issues.
     * TODO: for consistency this should not throw exeception, should return true or false like other methods like {@link #verifyCredentials}
     */
    public void deleteInfo(String description) throws Exception {
        List<Info> l = dbuser.getUserdata();
        int idxtodelete = -1;
        for (int i = 0; i < l.size(); ++i) {
            Info item = l.get(i);
            if (item.getDescription().equals(description)) {
                idxtodelete = i;
            }
        }
        if (idxtodelete == -1) {
            throw new RuntimeException("Provided descriptor does not exist");
        } else {
            l.remove(idxtodelete);
        }
        Dbops.updateUserInfo(this);
    }

    /**
     * Wraps {@link Dbops#updateUserInfo} to commit changes to Database.
     * Used mainly for committing reveal requests.
     * creation and deletion of secrets is done by {@link #createInfo} and {@link #deleteInfo}.
     * @param description the identifier of the secret to be update.
     * @throws Exception
     */
    public void updateInfo(String description) throws Exception {
        List<Info> l = dbuser.getUserdata();
        for (Info item : l)
            if (item.getDescription().equals(description)) {
                item.setEpochTime(Instant.now().toEpochMilli());
            }
        Dbops.updateUserInfo(this);
    }


    @Override
    public String toString() {
        return "email: " + email + ",\n password: " + password + ",\n session: " + sessiontoken;
    }

    public User(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public User(String email, String password, String sessiontoken) {
        this.email = email;
        this.password = password;
        this.sessiontoken = sessiontoken;
    }

    /* generate code starts */
    public User() {
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getSessiontoken() {
        return sessiontoken;
    }

    public void setSessiontoken(String sessiontoken) {
        this.sessiontoken = sessiontoken;
    }


    public Data getDbuser() {
        return dbuser;
    }

    public void setDbuser(Data dbuser) {
        this.dbuser = dbuser;
    }

    /* generate code ends */
}
